아래 내용은 **Spring Boot 2.3 이상**에서 지원하는 **`server.shutdown=graceful`** 설정이 **Tomcat**(기본 내장 서버)과 함께 동작할 때의 구체적인 시나리오를 정리한 것입니다.  
(버전에 따라 동작 방식이 다를 수 있으니, 사용하는 Spring Boot 버전의 공식 문서를 확인하시길 권장합니다.)

---

## 1. `server.shutdown=graceful`이란?

- **개념**  
  일반적으로 애플리케이션이 종료 신호(SIGHUP, SIGTERM 등)를 받으면, 스프링 부트는 즉시 톰캣을 멈추고(새 요청 거부 및 커넥션 끊기) 종료 과정을 진행합니다.  
  하지만 `server.shutdown=graceful`로 설정하면, **더 이상 새 요청은 받지 않되** 이미 수락된 요청(커넥션)에 대해서는 **일정 시간(Grace Period) 기다려 정상 응답**을 보낼 수 있도록 합니다.

- **목적**
    - **Graceful Shutdown**: 갑작스러운 종료로 인해 진행 중인 요청이 끊기지 않도록, 진행 중인 작업(예: 파일 업로드, 결제 처리 등)이 완료될 시간을 줍니다.
    - **운영 환경**: 무중단 배포(rolling update)나 서버 교체 시, 클라이언트가 에러 없이 정상 응답을 받을 수 있게 해줍니다.

---

## 2. 구체적인 종료 절차(시나리오)

1. **애플리케이션 종료 신호 감지**
    - 예: 쿠버네티스에서 SIGTERM 전송, 또는 수동으로 `kill -15` 등
    - Spring Boot는 종료 과정을 트리거합니다(`ApplicationContext`가 닫히기 시작).

2. **Tomcat이 새 요청 수락 중단**
    - `server.shutdown=graceful`이 활성화되어 있으면, **톰캣 커넥터가 더 이상 새로운 요청을 받지 않도록** 동작합니다.
    - Keep-Alive 연결도 새 요청은 받지 않습니다. (이미 열려 있던 소켓이더라도, 새로운 HTTP 요청은 거절)

3. **진행 중인 요청(커넥션) 처리**
    - 기존에 **이미 들어와서 실행 중**인 요청들은 계속 진행합니다.
    - **Worker Thread**(톰캣 스레드 풀에서 할당)가 해당 요청 처리를 완료할 때까지 기다립니다.
    - 이 때, **메인 스레드**(Spring의 shutdown 스레드)는 “Graceful Shutdown” 타이머(Grace Period)를 카운트하며, **Worker Thread**가 정상적으로 완료되길 대기합니다.

4. **Grace Period**
    - 기본적으로 Spring Boot는 30초(버전에 따라 다를 수 있음) 정도 대기하거나, `server.shutdown.grace-period`로 직접 설정할 수 있습니다.
    - 이 시간 내에 **모든 요청이 완료**되면 정상 종료로 넘어갑니다.
    - 만약 이 시간 내에 **요청이 끝나지 않으면**, 강제로 커넥션을 끊거나, 남은 스레드를 중단할 수 있습니다.
        - 어떤 방식으로 끊을지는 버전 및 설정에 따라 다를 수 있으나, 기본적으로는 **소켓을 닫고 남은 요청을 중단**하게 됩니다.

5. **남은 스레드 종료**
    - 진행 중인 요청이 모두 끝나거나(정상), Grace Period가 만료되어 더 이상 대기할 수 없으면(비정상), 톰캣이 스레드 풀을 정리하고 소켓을 닫습니다.
    - 이 시점에서 모든 **Worker Thread**가 작업을 종료(정상 응답 or 강제 중단)하면, 최종적으로 **Spring 애플리케이션**이 종료됩니다.

---

## 3. 질문별 세부 해설

### Q1. 톰캣 커넥션 중 응답하지 않은 요청이 있다면, 작업이 끝날 때까지 기다리는가?

- **예, 기본적으로 기다립니다.**
    - `server.shutdown=graceful` 상태에서는 새 요청은 거부하지만, 이미 수락된 요청에 대해서는 **Grace Period** 내에 정상적으로 처리할 기회를 줍니다.
    - 요청이 빠르게 끝나면 곧바로 종료하고, 길어지면 Grace Period만큼 대기합니다.

### Q2. 메인 스레드와 워커 스레드의 관계, 그리고 “모든 스레드가 종료”되는 시점?

- **메인 스레드(Shutdown Thread)**
    - Spring Boot 종료 과정을 관리하는 스레드입니다. Graceful Shutdown 설정이 있다면, 톰캣에 “새 요청을 막고, 기존 요청은 처리하라” 지시 후 **대기**합니다.
- **Worker Thread**
    - 톰캣이 요청을 처리하는 스레드 풀입니다. 기존 요청을 마무리한 뒤, **응답을 완료**하면 스레드가 다시 풀로 반환되고, 최종적으로 톰캣이 스레드 풀을 정리합니다.
- **종료 시점**
    - 모든 요청이 끝나거나, Grace Period가 만료되면 톰캣이 스레드 풀을 정리하고 종료합니다.
    - 즉, **Worker Thread가 모두 종료**되어야 최종적으로 Graceful Shutdown이 완료됩니다.

### Q3. Graceful Shutdown이 완전히 동작하려면?

1. **Spring Boot 버전**
    - Spring Boot 2.3 이상에서 `server.shutdown=graceful` 지원.
2. **톰캣 스레드 풀**
    - 남아있는 요청이 많은 경우, Grace Period 안에 끝날 수 있도록 충분한 스레드가 필요할 수 있음.
3. **요청 처리 시간**
    - 장시간 걸리는 요청(예: 대용량 파일 처리)이 Grace Period보다 길다면, 결국 강제 중단될 수 있음.
4. **Load Balancer / Kubernetes**
    - 무중단 배포를 위해선, LB나 쿠버네티스가 종료 신호를 보내고 일정 시간(Grace Period) 동안 트래픽을 새 노드로 분산시키는 설정도 필요합니다.

---

## 4. 정리

`server.shutdown=graceful` 옵션은 톰캣 서버가 **새로운 요청을 더 이상 받지 않고**, **이미 처리 중인 요청**이 있다면 **설정된 Grace Period** 내에서 완료될 시간을 보장해 주는 방식으로 **안정적인 종료**를 가능하게 해줍니다.

- **이미 들어온 요청**은 워커 스레드가 정상 완료할 때까지 대기합니다.
- **Grace Period**가 지날 때까지 끝나지 않는 요청은 강제로 끊길 수 있습니다.
- 모든 워커 스레드가 종료되고 나면, 최종적으로 애플리케이션이 종료됩니다.

무중단 배포 환경에서 애플리케이션이 갑작스럽게 종료되어 사용자 요청이 끊기지 않도록 하는 핵심 기능이므로,  
**배포 파이프라인**이나 **쿠버네티스 설정**과 함께 조율해 사용하는 것이 가장 효과적입니다.

간단히 말해, **Tomcat의 Graceful Shutdown은 “진행 중인 HTTP 요청”을 마무리하는 데 초점**을 맞추고 있습니다. 즉, **HTTP 응답이 이미 나간 상태**라면 톰캣 관점에서는 “해당 요청이 끝났다”고 판단합니다. 따라서 **그 이후에 코루틴이 별도 스레드(또는 Dispatcher)에서 계속 작업**하고 있어도, 톰캣의 “진행 중인 요청” 목록에는 포함되지 않습니다.

결과적으로, **기본 설정만으로는** 다음과 같은 시나리오가 발생할 수 있습니다:

1. **Tomcat Worker Thread**가 요청을 받아서 코루틴을 실행한 뒤,
2. 빠르게 HTTP 응답을 마치고(HTTP 레벨에서 요청은 종료),
3. 코루틴은 별도의 스레드 풀(예: `Dispatchers.Default`나 `Dispatchers.IO`)에서 백그라운드 작업을 계속 진행,
4. Graceful Shutdown 시, 톰캣은 “이미 응답이 나간 요청”으로 간주하므로 해당 작업을 **더 이상 추적하지 않음**.

이 경우, 톰캣 입장에서는 더 이상 처리 중인 HTTP 요청이 없으므로 “모든 요청이 완료됐다”고 보고 곧바로 종료를 진행할 수 있습니다. 즉, **코루틴이 남아 있는 작업을 끝낼 때까지 대기하지 않을 가능성**이 큽니다.

---

## 왜 이런 현상이 생기는가?

- **Tomcat의 요청 추적 기준**  
  톰캣은 “요청 → 응답” 사이클이 끝나면, 해당 커넥션(또는 Worker Thread)은 “완료”로 간주합니다.  
  코루틴이 내부적으로 비동기/백그라운드 작업을 이어가더라도, 톰캣은 이를 알 길이 없습니다.

- **스프링 부트 Graceful Shutdown의 초점**  
  `server.shutdown=graceful`은 톰캣이 “아직 응답하지 않은 요청”을 일정 시간(Grace Period) 동안 마무리하도록 해주는 기능입니다.  
  “이미 응답을 보낸 뒤 백그라운드로 진행 중인 작업”은 Graceful Shutdown이 인지할 수 있는 범위 밖입니다.

---

## 그럼 백그라운드 코루틴 작업도 안전하게 마무리하려면?

1. **Spring 애플리케이션 종료 훅(Hook) 이용**
    - 예: `@PreDestroy`나 `DisposableBean`을 구현해, **애플리케이션 컨텍스트가 닫힐 때** 남은 코루틴 작업을 확인하고 종료/대기하는 로직을 넣을 수 있습니다.
    - 코루틴 스코프(CoroutineScope)를 전역적으로 관리하면서, 종료 시점에 `cancel()` 또는 `join()`을 통해 마무리하는 방법도 있습니다.

2. **“HTTP 응답 = 작업 완료” 구조로 설계**
    - 요청이 오면 코루틴으로 작업을 위임하되, **HTTP 응답은 코루틴이 끝난 후에 반환**하도록 설계하면, 톰캣이 요청을 “진행 중”으로 인식하게 됩니다.
    - 이 경우, Graceful Shutdown 시 톰캣은 해당 요청이 끝날 때까지(응답이 나갈 때까지) 대기합니다.

3. **별도 Job/Worker 관리**
    - 요청과 무관하게 장시간 걸리는 작업은 Spring Batch나 별도 Worker 프로세스에서 수행하고, Graceful Shutdown 시 해당 프로세스도 안전하게 종료하도록 설계할 수 있습니다.

---

## 정리

- **Tomcat Graceful Shutdown**은 “아직 응답하지 않은 HTTP 요청”을 마무리하기 위한 기능이며, 이미 응답이 나간 요청(또는 백그라운드 비동기 작업)은 톰캣 레벨에서 추적하지 않습니다.
- **백그라운드 코루틴이 중요한 작업**을 수행 중이라면, **Spring 애플리케이션 레벨**에서 종료 훅을 활용하거나, 요청-응답 구조를 변경하여 작업이 끝날 때까지 응답을 지연시키는 등 별도의 설계가 필요합니다.
- 그렇지 않으면, 톰캣이 “처리할 요청이 없다”고 판단해 애플리케이션을 종료해 버리므로, 코루틴 작업이 도중에 끊길 수 있습니다.