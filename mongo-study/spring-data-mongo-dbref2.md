MongoDB에서 두 가지 방식으로 문서 간의 관계를 표현할 수 있습니다. 한 가지는 **DBRef**를 사용하는 것이고, 다른 한 가지는 단순히 참조 대상 문서의 **ObjectId** 값을 저장하는 방식입니다. 아래 여러 관점에서 두 방식의 차이를 구체적으로 살펴보겠습니다.

---

## 1. 구조적 차이

| 관점        | DBRef                                                                    | ObjectId 값               |
|-----------|--------------------------------------------------------------------------|--------------------------|
| **구조**    | JSON 문서 내부에 `{"$ref": "컬렉션명", "$id": ObjectId, "$db": "DB명(선택)"}` 형태로 저장 | 참조 대상의 ObjectId 값 하나만 저장 |
| **메타 정보** | 참조하는 컬렉션과 데이터베이스 정보를 포함                                                  | 단순 식별자만 포함               |

- **DBRef**는 참조 대상에 대한 추가 정보를 포함하기 때문에, 읽을 때 어느 컬렉션의 어떤 DB에 저장된 문서인지 명시적으로 알 수 있습니다.
- 단순 **ObjectId**는 참조 대상 문서의 고유 식별자만 가지고 있어, 애플리케이션 로직에서 참조하는 컬렉션을 이미 알고 있어야 합니다.

---

## 2. 쿼리 및 조회 측면

| 관점           | DBRef                                                                                                         | ObjectId 값                                                                   |
|--------------|---------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| **자동 참조 해제** | 일부 드라이버(예: Spring Data MongoDB)는 `@DBRef` 어노테이션을 사용해 자동으로 참조를 해제하지만, 이는 내부적으로 추가 쿼리(또는 lazy loading)를 발생시킵니다. | 단순 값이므로 별도 조인이나 참조 해제 로직 없이 직접 조회 가능. 필요 시 Aggregation의 `$lookup`을 활용할 수 있음. |
| **쿼리 보정**    | DBRef 구조를 고려해 쿼리 작성 시 `$ref`, `$id` 필드를 명시해야 하는 경우가 있음.                                                       | 단순 ObjectId이므로, 쿼리 시 해당 필드에 대해 바로 인덱스를 활용할 수 있음.                             |

- **DBRef**의 경우, 자동 참조 해제가 동작할 때 백그라운드에서 추가 조회가 이루어지므로 성능에 영향을 줄 수 있습니다.
- **ObjectId 값**은 단순하므로 조회 쿼리가 더 직관적이며, 필요한 경우 애플리케이션 레벨이나 Aggregation의 `$lookup`을 사용해 join-like 동작을 구현할 수 있습니다.

---

## 3. 성능 및 인덱싱 관점

- **DBRef**
    - **추가 조회**: 자동 참조 해제(혹은 lazy 로딩)를 사용하는 경우, 여러 문서를 참조할 때 별도의 조회 쿼리가 발생할 수 있습니다.
    - **인덱스**: DBRef 필드는 내부 구조로 저장되므로, 인덱스 설정 시 주의가 필요합니다.

- **ObjectId 값**
    - **단순성**: 단순 ObjectId를 저장하면, 하나의 값에 대해 인덱싱을 적용하기 쉬워 조회 속도에 유리합니다.
    - **조인 처리**: 필요 시 `$lookup` 등 Aggregation을 이용해 조인을 구현할 수 있으나, 이는 명시적으로 작성해야 합니다.

---

## 4. 스키마 유지 및 유연성

- **DBRef**
    - 컬렉션 이름이나 데이터베이스 정보를 포함하기 때문에, 스키마가 명시적으로 드러나지만 컬렉션 명이 변경될 경우 DBRef도 함께 수정해야 하는 부담이 있습니다.

- **ObjectId 값**
    - 단순 참조이므로 스키마 변화에 대해 더 유연합니다. 참조 대상 컬렉션이 변경되더라도 애플리케이션 로직에서 이를 처리하면 됩니다.

---

## 5. Spring Data MongoDB에서의 사용

- **@DBRef 어노테이션**
    - Spring Data MongoDB에서는 `@DBRef` 어노테이션을 사용하여 DBRef 방식으로 참조할 수 있습니다.
    - 단점: 자동 참조 해제 시 다수의 추가 쿼리가 발생할 수 있으며, lazy loading이 적용될 때 예상치 못한 성능 이슈가 발생할 수 있습니다.

- **직접 ObjectId 저장**
    - 참조 대상의 ObjectId를 직접 저장하는 방식은, 연관된 문서를 가져올 때 개발자가 명시적으로 쿼리를 구성하거나 Aggregation의 `$lookup`을 사용하는 등, 보다 직접적인 제어가 가능합니다.
    - 장점: 불필요한 추가 조회 없이 단순하고 빠른 조회가 가능합니다.

---

## 6. 정리

- **DBRef 사용 시**
    - **장점:**
        - 참조 대상에 대한 컬렉션과 DB 정보를 포함하므로, 명시적이고 직관적인 관계 표현이 가능.
        - 일부 프레임워크에서 자동 참조 해제를 지원.
    - **단점:**
        - 자동 참조 해제 시 추가 쿼리 및 lazy loading에 따른 성능 저하 우려.
        - DB 스키마 변경 시 DBRef 수정 부담.

- **ObjectId 값 사용 시**
    - **장점:**
        - 단순 구조로 인한 성능 최적화에 유리.
        - 인덱싱 및 쿼리 작성이 간편.
        - 스키마 변경에 대해 더 유연하게 대응 가능.
    - **단점:**
        - 참조 대상의 컬렉션 정보가 내포되어 있지 않아, 애플리케이션 로직에서 이를 명시적으로 관리해야 함.

---

## 결론

MongoDB에서 DB 간 관계를 설계할 때는 애플리케이션의 특성과 성능 요구사항을 고려해야 합니다. 자동 참조 해제 기능이 편리할 수 있으나, 대규모 데이터나 빈번한 조회가 이루어지는 환경에서는 단순 ObjectId를 사용해 직접 쿼리를 구성하는 방식이 더 효율적일 수 있습니다. 상황에 맞게 두 방식을 적절히 선택하는 것이 중요합니다.

아래는 두 가지 방식으로 Post 문서의 author를 업데이트하는 예시입니다.  
첫 번째는 **DBRef**로 저장된 경우, 두 번째는 **값 객체(ObjectId)**로 저장된 경우입니다.

---

### 1. DBRef로 저장된 경우

DBRef는 내부적으로 다음과 같이 저장됩니다:

```json
"author": {
"$ref": "authors",
"$id": ObjectId("..."),
"$db": "현재DB" // 생략 가능
}
```

업데이트 쿼리는 MongoDB 셸에서 다음과 같이 작성할 수 있습니다:

```javascript
db.posts.update(
    {_id: ObjectId("post_id")},
    {
        $set: {
            author: {
                $ref: "authors",
                $id: ObjectId("new_author_id")
            }
        }
    }
)
```

**설명:**

- 조건: `_id`가 업데이트할 대상 Post 문서를 지정합니다.
- `$set`: author 필드를 새 DBRef 값으로 업데이트합니다.
- `$ref`: 참조할 컬렉션 이름 ("authors")를 지정합니다.
- `$id`: 새 Author의 ObjectId를 지정합니다.

---

### 2. 값 객체(ObjectId)로 저장된 경우

만약 Post가 author를 DBRef 대신 단순 ObjectId 값(예를 들어, 필드명이 `author_id` 혹은 `author`)로 저장하는 경우에는 다음과 같이 업데이트할 수 있습니다:

```javascript
db.posts.update(
    {_id: ObjectId("post_id")},
    {
        $set: {
            author: ObjectId("new_author_id")
        }
    }
)
```

또는 만약 필드명이 `author_id`라면:

```javascript
db.posts.update(
    {_id: ObjectId("post_id")},
    {
        $set: {
            author_id: ObjectId("new_author_id")
        }
    }
)
```

**설명:**

- 조건: 업데이트할 Post 문서를 `_id`로 지정합니다.
- `$set`: author(또는 author_id) 필드를 단순 ObjectId로 업데이트합니다.
- DBRef의 메타정보 없이 단순히 참조 대상의 식별자만 저장되므로, 쿼리가 더 간단해지고 인덱싱에도 유리할 수 있습니다.

---

두 방식 모두 상황에 맞게 사용하면 되며, DBRef는 추가 메타데이터($ref, $id)를 포함해 참조의 출처를 명시적으로 표현하는 반면, 단순 ObjectId 방식은 더 단순하고 성능 면에서 유리할 수 있습니다.

아래는 DBRef 방식과 단순 ObjectId 방식(필드명이 **author_Id**인 경우) 각각에 대해 인덱스를 추가하는 방법입니다.

---

### 1. DBRef 방식 인덱스 추가

DBRef 방식으로 저장된 경우, 내부에 **`$id`** 필드에 실제 ObjectId가 포함되어 있습니다.  
따라서, 인덱스를 생성할 때는 **`author.$id`** 필드에 대해 인덱스를 추가해야 합니다.

```javascript
db.posts.createIndex({"author.$id": 1})
```

- **설명:**  
  위 쿼리는 `posts` 컬렉션에서 `author` 필드 내부의 `$id`에 대해 오름차순 인덱스를 생성합니다.  
  이 방식은 DBRef 객체가 `{ "$ref": "authors", "$id": ObjectId("...") }`와 같이 저장되기 때문에, 실제 참조 대상인 `$id`를 기준으로 인덱싱해야 효율적인 조회가 가능합니다.

---

### 2. ObjectId 방식 인덱스 추가 (필드명: author_Id)

단순 ObjectId 값이 **author_Id** 필드에 저장되는 경우, 인덱스는 해당 필드 자체에 대해 생성하면 됩니다.

```javascript
db.posts.createIndex({"author_Id": 1})
```

- **설명:**  
  위 쿼리는 `posts` 컬렉션에서 `author_Id` 필드에 대해 오름차순 인덱스를 생성합니다.  
  단순 ObjectId 방식은 구조가 단순하여, 필드명 그대로 인덱스 생성이 가능하며 쿼리 작성도 직관적입니다.

---

이처럼 두 방식은 저장 구조가 다르기 때문에, 인덱스 생성 시 대상 필드가 다르게 지정됩니다.

- **DBRef 방식:** 내부 `$id` 필드에 인덱스 추가 (`"author.$id": 1`)
- **ObjectId 방식 (author_Id):** 필드 자체에 인덱스 추가 (`"author_Id": 1`)

Spring Data MongoDB에서 `@DBRef` 필드를 lazy로 지정하려면, 어노테이션의 `lazy` 속성을 `true`로 설정하면 됩니다. 기본 값은 `false`이며, 이 경우에는 참조가 즉시(eager) 로드됩니다.

예시 코드는 다음과 같습니다:

```kotlin
@Document(collection = "posts")
data class Post(
    val title: String,
    val content: String,
    @DBRef(lazy = true) // lazy 로딩을 지정하여, 실제로 해당 필드에 접근할 때 Author를 조회합니다.
    val author: Author
)
```

이와 같이 설정하면, Post 객체를 조회할 때 `author` 필드는 실제 접근 시점에 로드되며, 기본적으로는 lazy가 false여서 Post 조회 시 즉시 Author가 로드됩니다.

Spring Data MongoDB에서 @DBRef를 사용할 때, 내부적으로 동일한 참조가 여러 번 조회되는 것을 방지하기 위해 일종의 "동일성(identity) 캐싱" 메커니즘이 존재할 수 있습니다. 그러나 이 메커니즘은 상황에 따라 다르게 동작하며, 일반적인 경우 N+1 쿼리 문제가 발생할 가능성이 큽니다. 구체적으로 살펴보면:

---

### 1. 내부 캐싱(동일성 보장) 메커니즘

- **변환 컨텍스트 내 캐싱:**  
  Spring Data MongoDB는 `MappingMongoConverter`를 통해 DBRef를 해제할 때, 동일한 ID를 가진 대상 문서가 이미 로드되었다면 이를 재사용할 수 있도록 내부적으로 캐싱(즉, identity map)을 사용합니다.
    - 예를 들어, 여러 Post가 동일한 Author를 참조하는 경우, 변환 과정 중에 한 번 Author가 조회되면 같은 세션(혹은 변환 컨텍스트) 내에서는 이미 로드된 Author 인스턴스를 재사용할 수 있습니다.

- **제한 사항:**  
  이 캐싱은 한정된 범위(변환 또는 영속성 컨텍스트 내)에서만 유효합니다.
    - **영속성 컨텍스트 범위:** Spring Data MongoDB는 JPA처럼 완전한 2차 캐시를 제공하지 않으므로, 캐싱은 주로 한 번의 쿼리 실행이나 특정 변환 세션 내에서만 작동합니다.
    - **Lazy 로딩:** Lazy 로딩이 적용된 경우, 실제로 해당 DBRef에 접근하는 시점에 각 DBRef마다 별도의 쿼리가 실행될 수 있습니다. 즉, 아직 로드되지 않은 참조에 접근할 때마다 새로운 쿼리가 발생할 가능성이 큽니다.

---

### 2. N+1 문제 발생

- **즉시 로딩(eager loading) 시:**  
  Post 문서를 조회할 때 DBRef 필드가 즉시 로딩된다면, Spring Data MongoDB는 각 Post에 대해 해당 Author를 해제하기 위해 별도의 쿼리를 실행할 수 있습니다.
    - 만약 100개의 Post가 각각 Author를 참조하고 있고, 캐싱 메커니즘이 동일 컨텍스트 내에서만 작동한다면, 처음 조회 시점에 1번의 Post 조회 쿼리와 최대 100번의 Author 조회 쿼리가 발생할 수 있습니다.

- **Lazy 로딩 시:**  
  lazy 속성을 사용하면, Post 조회 시점에는 DBRef가 아직 해제되지 않고, 실제 Author에 접근할 때마다 해당 DBRef를 해제하기 위한 별도의 쿼리가 실행됩니다.
    - 이 경우에도 동일한 Author에 대한 조회가 캐싱될 가능성이 있지만, 각 Post가 lazy 로딩 상태에서 개별적으로 Author에 접근한다면 여전히 N+1 문제가 발생할 가능성이 큽니다.

- **실제 동작:**  
  만약 여러 Post가 같은 Author ID를 참조한다고 하더라도, 캐싱이 한 세션 내에서만 효과적이므로, 조회하는 타이밍이나 lazy 로딩 등의 설정에 따라 동일한 Author에 대해 여러 번 조회하는 상황(N+1 쿼리)이 발생할 수 있습니다.

---

### 결론

- **내부 캐싱 가능성:**  
  Spring Data MongoDB는 변환 과정에서 동일한 DBRef를 한 번 조회한 후 동일 컨텍스트 내에서는 재사용할 수 있으나, 이 캐싱은 제한적입니다.

- **N+1 문제:**  
  특히 lazy 로딩을 사용할 경우, 각 DBRef에 접근할 때마다 별도의 쿼리가 발생할 수 있으므로, 100개의 Post를 조회하면 최대 101번(Posts 조회 1번 + 각 Post마다 Author 조회 100번)의 쿼리가 실행될 가능성이 있습니다.

따라서, 동일 참조가 캐싱되더라도 일반적인 상황에서는 N+1 쿼리 문제가 발생할 수 있으며, 이를 방지하기 위해 Aggregation의 `$lookup`을 사용하는 방법이나, DBRef 대신 단순 ObjectId를 사용하여 직접 join 처리를 고려하는 것이 좋습니다.

Spring Data MongoDB에서 @DBRef를 사용할 때, 내부적으로 동일한 참조가 여러 번 조회되는 것을 방지하기 위해 일종의 "동일성(identity) 캐싱" 메커니즘이 존재할 수 있습니다. 그러나 이 메커니즘은 상황에 따라 다르게 동작하며, 일반적인 경우 N+1 쿼리 문제가 발생할 가능성이 큽니다. 구체적으로 살펴보면:

---

### 1. 내부 캐싱(동일성 보장) 메커니즘

- **변환 컨텍스트 내 캐싱:**  
  Spring Data MongoDB는 `MappingMongoConverter`를 통해 DBRef를 해제할 때, 동일한 ID를 가진 대상 문서가 이미 로드되었다면 이를 재사용할 수 있도록 내부적으로 캐싱(즉, identity map)을 사용합니다.
    - 예를 들어, 여러 Post가 동일한 Author를 참조하는 경우, 변환 과정 중에 한 번 Author가 조회되면 같은 세션(혹은 변환 컨텍스트) 내에서는 이미 로드된 Author 인스턴스를 재사용할 수 있습니다.

- **제한 사항:**  
  이 캐싱은 한정된 범위(변환 또는 영속성 컨텍스트 내)에서만 유효합니다.
    - **영속성 컨텍스트 범위:** Spring Data MongoDB는 JPA처럼 완전한 2차 캐시를 제공하지 않으므로, 캐싱은 주로 한 번의 쿼리 실행이나 특정 변환 세션 내에서만 작동합니다.
    - **Lazy 로딩:** Lazy 로딩이 적용된 경우, 실제로 해당 DBRef에 접근하는 시점에 각 DBRef마다 별도의 쿼리가 실행될 수 있습니다. 즉, 아직 로드되지 않은 참조에 접근할 때마다 새로운 쿼리가 발생할 가능성이 큽니다.

---

### 2. N+1 문제 발생

- **즉시 로딩(eager loading) 시:**  
  Post 문서를 조회할 때 DBRef 필드가 즉시 로딩된다면, Spring Data MongoDB는 각 Post에 대해 해당 Author를 해제하기 위해 별도의 쿼리를 실행할 수 있습니다.
    - 만약 100개의 Post가 각각 Author를 참조하고 있고, 캐싱 메커니즘이 동일 컨텍스트 내에서만 작동한다면, 처음 조회 시점에 1번의 Post 조회 쿼리와 최대 100번의 Author 조회 쿼리가 발생할 수 있습니다.

- **Lazy 로딩 시:**  
  lazy 속성을 사용하면, Post 조회 시점에는 DBRef가 아직 해제되지 않고, 실제 Author에 접근할 때마다 해당 DBRef를 해제하기 위한 별도의 쿼리가 실행됩니다.
    - 이 경우에도 동일한 Author에 대한 조회가 캐싱될 가능성이 있지만, 각 Post가 lazy 로딩 상태에서 개별적으로 Author에 접근한다면 여전히 N+1 문제가 발생할 가능성이 큽니다.

- **실제 동작:**  
  만약 여러 Post가 같은 Author ID를 참조한다고 하더라도, 캐싱이 한 세션 내에서만 효과적이므로, 조회하는 타이밍이나 lazy 로딩 등의 설정에 따라 동일한 Author에 대해 여러 번 조회하는 상황(N+1 쿼리)이 발생할 수 있습니다.

---

### 결론

- **내부 캐싱 가능성:**  
  Spring Data MongoDB는 변환 과정에서 동일한 DBRef를 한 번 조회한 후 동일 컨텍스트 내에서는 재사용할 수 있으나, 이 캐싱은 제한적입니다.

- **N+1 문제:**  
  특히 lazy 로딩을 사용할 경우, 각 DBRef에 접근할 때마다 별도의 쿼리가 발생할 수 있으므로, 100개의 Post를 조회하면 최대 101번(Posts 조회 1번 + 각 Post마다 Author 조회 100번)의 쿼리가 실행될 가능성이 있습니다.

따라서, 동일 참조가 캐싱되더라도 일반적인 상황에서는 N+1 쿼리 문제가 발생할 수 있으며, 이를 방지하기 위해 Aggregation의 `$lookup`을 사용하는 방법이나, DBRef 대신 단순 ObjectId를 사용하여 직접 join 처리를 고려하는 것이 좋습니다.