# 코틀린 동시성 프로그래밍

# 1장

## 프로세스

프로세스는 실행 중인 애플리케이션의 인스턴스다. 애플리케이션이 시작될 때마다 애플리케이션의 프로세스가 시작된다. 프로세스는 상태를 갖고 있다. 리소스를 여는 핸들, 프로세스 ID, 데이터, 네트워크 연결 등은 프로세스 상태의 일부이며 해당 프로세스 내부의 스레드가 액세스를 할 수 있다.

## 스레드

실행 스레드는 프로세스가 실행할 일연의 명령을 포함한다. 따라서 프로세스는 최소한 하나의 스레드를 포함하며 이 스레드는 애플리케이션의 진입점을 실행하기 위해 생성된다. 보통 진입점은 애플리케이션 main() 함수이며 메인 스레드라 하는데 프로스세의 라이프 사이클과 밀접하게 연관된다. 스레드가 끝나면 프로세스의 다른 스레드와 상관없이 프로세스가 종료된다.

```kotlin
fum main (args: Array<String>) {
    dowork()
}
```

기본적인 애플리케이션이 실행되면 main 함수의 명령 집합이 포함된 메인 스레드가 생성된다.dowork()은 메인 스레드에서 실행되므로 wowork()이 종료되면 애플리케이션의 실행이 종료된다.

각 스레드는 스레드가 ㅅ혹한 프로세스에 포함된 리소스를 액세스하고 수정할 수 있지만 스레드 로컬 스토리지라는 자체 저장소도 갖고 있다.

스레드 안에서 명령은 한 번에 하나씩 실행돼 스레드가 블록되면 블록이 끝날 때까지 같은 스레드에서 다른 명령을 실행할 수 없다. 그러나 많은 스레드가 같은 프로세스에서 생성될 수 있으며 서로 통신할 수 있다. 따라서 애플리케이션이 사용자 경험에 부정적인 영향을 미칠 수 있는 스레드는 블로킹하지 않아야 한다. 블록킹할 떄는 블록킹 작업을 별도의 전용 스레드에 할당해야한다. GUI 애플리케이션은 애플리케이션의 응답성을 항상 유지하기 위해서 UI 스레드를 블록하지 않는다.

코틀린이 동시성을 구현한 방식을 보면 여러분이 직접 스레드를 시작하거나 중지할 필요가 없다는 것을 알게된다. 한두 줄의 코드로 코틀린이 특정 스레드나 스레드 풀을 생성해서 코루틴을 실행하도록 지시하기만 하면된다. 스레드와 관련된 나머지 처리는 프레임워크에 의해 수행된다.

## 코루틴

코틀린 문서에서는 코툴린을 경량 스레드라고 한다. 대부분 스레드와 마찬가지로 코루틴이 프로세스가 실행할 명령어 집합의 실행을 정의하기 때문이다. 또한 코루틴은 스레드와 비슷한 라이프 사이클을 갖고 있다.

코루틴은 스레드 안에서 실행된다. 스레드 하나에 많은 코루틴이 있을 수 있지만 주어진 시간에 하나의 스레드에서 하나의 명령만 실행될 수 있다. 즉 같은 스레드에 10개의 코루틴이 있다면 해당 시점에 하나의 코루틴만 실행된다.

스레드와 코루틴의 가장 큰 차이점은 코루틴이 빠르고 적은 비용으로 생성할 수 있다는 것이다. 추천 개의 코루틴도 쉽게 생성할 수 있ㅇ므ㅕ, 수천 개의 스레드를 생성하는 것보다 빠르고 자원도 훨씬 적게 사용한다.

```kotlin
suspend fun createCoroutines(amount: Int) {
    val jobs = ArrayList<Job>()
    for (i in 1..amount) {
        jobs += GlobalScope.launch {
            delay(1000)
        }
    }
    jobs.forEach { it.join() }
}

@Test
@DelicateCoroutinesApi
fun `코루틴 생성 테스트`() = runBlocking {
    println("${Thread.activeCount()} thread active at the start")

    val time = measureTimeMillis {
        createCoroutines(10_000)
    }

    println("${Thread.activeCount()} thread active at the end")
    println("Took $time ms")

}


```

amount에 지정된 수만큼 코루틴을 생성해 각 코루틴을 1초 간 지연시킨 이후 모든 코루틴이 종료될 때까지 기다렸다가 반환한다.

```
# amount = 1
4 thread active at the start
7 thread active at the end
Took 1016 ms

# amount = 10_000
4 thread active at the start
15 thread active at the end
Took 1072 ms

# amount = 100_000
4 thread active at the start
15 thread active at the end
Took 1291 ms

# amopunt = 1_000_000
4 thread active at the start
15 thread active at the end
Took 2842 ms
```

테스트 환경에서 amount를 10,000으로 실행할 때 약 1,072ms가 걸리는데 반해 100,000으로 실행하는데 1,291ms가 소요됐다. **코틀린의 고정된 크기의 스레드 풀을 사용하고 코루틴을 스레드들에 배포하기 떄문에 실행 시간이 매우 적게 증가한다.** 따라서 수 천개의 코루틴을 추가하는 것은 거의 영향이 없다. 코루틴이 일시 중단되는 동안 실행 중인 스레드는 다른 코루틴을 실행하는 데 사용되며 코루틴은 시작 또는 재개될 준비 상태가 된다.

Thread 클래스의 activeCount() 메드를 활용하면 활성화된 스레드 수를 알 수 있다. 10,000개의 코루틴을 생성하기 위해서는 4개의 스레드만 생성하면 된다. 그러나 amount 값을 1로 하면 7개의 스레드만 필요하다.

**코루틴이 특성 스레드 안에서만 실행되더라도 스레드와 묶이지 않는다는 점을 이해햐아한다.** 코루틴의 일부를 특정 스레드에서 실행하고, 실행을 중지한 다음 나중에 다른 스레드에서 계속 실행하는 것이 가능하다. 코틀린이 실행 가능한 스레드로 코루틴을 이동시키기 떄문이다. createCoroutines() amount를 3으로 하고, launch() 블록을 다음과 같이 변경해서 현재 실행 중인 스레드를 출력시키면 실제 내부에서 일어나는 일을 볼 수 있다.

```kotlin
val jobs = ArrayList<Job>()
for (i in 1..amount) {
    jobs += GlobalScope.launch {
        println("Started $i in ${Thread.currentThread().name}")
        delay(1_000)
        println("Finished $i in ${Thread.currentThread().name}")
    }
}
jobs.forEach { it.join() }

Started 3 in DefaultDispatcher-worker-2 @coroutine#4
Started 1 in DefaultDispatcher-worker-1 @coroutine#2
Started 2 in DefaultDispatcher-worker-3 @coroutine#3
Finished 3 in DefaultDispatcher-worker-1 @coroutine#4
Finished 2 in DefaultDispatcher-worker-2 @coroutine#3
Finished 1 in DefaultDispatcher-worker-3 @coroutine#2
```

스레드는 한 번에 하나의 코루틴만 실행할 수 있기 떄문에 프레임워크가 필요에 따라 코루틴을 스레들 사이에 옮기는 역할을 한다. 코루틴은 개발자가 코루틴을 실행할 스레드를 지정하거나 코루틴을 해당 스레드로 제한할지 여부를 지정할 수 있을 만큼 충분히 유연하다.

## 내용 정리

스레드를 블록한다는 거은 그 스레드에ㅓ 코드의 실행을 중지한다는 의미인데, 사용자와 상호작용하는 스레드는 블록하지 않아야 하낟. 코루틴이 기본적으로 스레드 안에 존재하지만 스레에 얽ㅐㅣ지 않은 가벼운 스레드라는 것을 알게 됐다.

![](images/coroutine-1.png)

동시성은 애플리케이션이 동시에 한 개이상의 스레드에서 실행 될 때 발생한다. 공시성이 발생하려면 두 개 이상의 스레드가 생성돼 하며, 애플리케이션이 제대로 작동하려면 이런 스레드 간의 통신과 동기화가 필요하다.

## 동시성에 대해

```kotlin
fun getProfile(id: Int) : Profile {
    val basicUSerInfo = getUserInfo(id)
    val contactInfo = getContactInfo(id)
  
    return createProfile(basicUSerInfo, contactInfo)
}
```

사용자 정보가 반환되기 전까지 연락처 정보를 요청하지 않는다. 이것이 순차 코드의 장점이다. 장확한 실행순서를 쉽게 알수 있어 예층하지 못하는 일이 벌어지지 않을 것이다. 그러나 순차 코드에는 두 가지 큰 문제점이 있다.

* 동시성 코드에 비해 성능이 저하될 수 있음
* 코드가 실행되는 하드웨어를 제대로 활용하지 못할 수 있음

basicUSerInfo, contactInfo이 서로 의존하지 않아 이들을 동시에 호출할 수 있다.

```kotlin
suspend fun getProfile(id: Int) : Profile {
    val basicUSerInfo = asyncGetUserInfo(id)
    val contactInfo = asyncGetContactInfo(id)
  
    return createProfile(basicUSerInfo.await(), contactInfo.await())
}
```

suspend를 통해 일시 중단 함수로 정의 했고, asyncGetUserInfo(), asyncGetContactInfo()는 서로 다른 스레드에서 실행되도록 작성 했기 때문에 동시성이라고 한다.

await() 호출을 통해 asyncGetUserInfo(), asyncGetContactInfo()가 모두 완료될 때까지 getProfile()의 실행을 일시 중단하는 것이다. 둘 다 완료됐을 떄만 createProfile()의 실행을 잃시 중단하는 것이다. 둘 다 완료됐을 떄만 createProfile이 실행된다.

## 동시성은 병렬성이 아니다

흔히 동시성과 병렬성을 혼동하곤 한다. 어쨋든 두 개의 코드가 동시에 실행된다는 점에서 둘 다 상당히 비슷해 보이긴 하지만, 이 둘을 나눌 명확한 선을 규정할 것이다.

* 동시성은 두 개 이상의 알고리즘의 실행 시간이 겹칠 떄 발생한다. 중첩이 발생하려면 두 개 이상의 슬행 스레드가 필요하다. 이런 스레드들이 단일 코어에서 실행되면 병렬이 아니라 동시에 실행되는데, 단일 코어가 서로 다른 스레드의 인스트럭션을 교차 배치해서, 스레드들의 실행을 효율적으로 겹쳐서 실행한다.
* 병렬은 두 개의 알고리즘이 정확히 같은 시점에 실행될 떄 발생한다. 이것이 가능하려면 2개 이상의 코어와 2개 이상의 스레드가 있어야 각 코어가 동시에 스레들의 인스트럭션을 실행할 수 있다. **병렬은 동시성을 의미하지만 동시성은 병렬성이 없어도 발생할 수 있다는 점에서 유의하자.**

## CPU 바운드와 I/O 바운드

동시성과 병렬성이 CPU나 I/O 연산에 바인딩됐는지 여부에 따라 알고리즘의 성능에 어떻게 영햐응ㄹ 미칠 수 있는지를 알아본다.

### CPU 바운드

CPU만 완료하면 되는 작업을 중심으로 구현되는 알고리즘이 많다. 알고리즘의 성능은 실행 중인 CPU의 성능에 좌우되며 CPU만 업그레이드해도 성능이 향상된다.

### I/O 바운드

I/O 바운드는 입출력 장치에 의존하는 알고리즘이다. 실행 시간은 입출력 장치의 속도에 따라 달라지는데. 예컨데 문서를 읽어서 처리하는 알고리즘이면 알고리즘이 I/O 바운드다.

예를 들어 파일을 하드 드라이브에 저장하면 SSD에 저장하는 겻우보다 애플리케이션 성능이 더 나빠진다. 네트워킹이나 컴퓨터 주변기기로부터 입력을 받은 작업들도 I/O 작업이다. I/O 바운드 알고리즘은 I/O 작업을 기준으로 성능에 대한 병목 현상을 이르키는데, 최적화가 외부 시스템이나 장치에 의존한다는 것을 의미한다.

## CPU 바운드 알고리즘에서의 동시성과 병렬성

CPU 바운드 알고리즘의 경우 다중 코어에서 병렬성을 활요앟면 성능을 향상시킬 수 있지만 단일 코어에서 동시성을 구현하면 성능이 저하되기도 한다. 3개의 스레드로 단어를 분리하는 실행을 하면 다음과 같다

![](images/coroutine-2.png)

### 단일 코어에서 실행

단일 코어에서 실행된다면 하나의 코어가 3개의 스레드 사이에 교착 배치 되며 매번 일정량의 단어를 필터링하고 다음 스레드로 전환된다. 전환 프로세스를 컨텍스트 스위칭이라고 한다.

컨텍스트 스위칭은 현재 스레드의 사애틀ㄹ 저장한 후 다음 스레드의 사앹를 적재해야 하기 떄문에 전체 프로세스에 오버헤드가 발생한다. 오버헤드로 인해 다중 스레드로 구현한 로직 앞에서 본 순차적으로 구현에 비해 단일 코어 머신에서는 더 오래 걸릴 가능성이 있다. 순차적으로 구현에서 단일 코어가 모든 작업을 수행하지만 컨텍스트 스위칭이 발생하지 않기 떄문에이다.

### 병령 실행

병렬 실행의 경우 각 스레드가 하나의 전용 코어에서 실행된다고 가정하면 실행은 순차적 실행의 약 3분의 1이 될 것이다. 각 코어는 1,000개의 단어를 중단 없이 필터링해서 작업을 완료하면 데 필요한 총 시간을 줄일 것이다.

CPU 바운드 알고리즘을 위해서는 현재 사용중인 장치의 코어 수를 기준으로 적절한 스레드 수를 생성하도록 고려해야한다. 이렇게 하면 CPU 바운드 알고리즘을 실행하기 위해 생성된 스레드 풀인 코틀린의 CommonPool을 활용할 수 있다.

> CommonPool의 크기는 머신의 코어 수에서 1을 뺸 갑싱다. 4코어가 있는 머신의 CommonPool 크기는 3이다.

## I/O 바운드 알고리즘에서의 동시성 대 병렬성

지속적인 대기는 단일 코어 기기에서 대기하는 중에 다른 유용한 작업에 프로세스를 사용할 수 있도록 한다. 따라서 I/O 바운드 동시성 알고리즘은 병렬이거나 단일 코어에 상관없이 유사하게 수행될 것이다.


## 동시성이 어려운 이유


### 레이스 컨디션

### 원자성 위반

### 교착 상태

### 라이브 락

## 코틀린에서의 동시성


### 넌 블로킹

### 명시적인 선언

### 가독성

### 기본형 활용

### 유연성

## 코틀린 동시성 관련 개념과 용어

### 일시 중단 연산

### 일시 중단 함수

### 람다 일시 중단

### 코루틴 디스패처


## 요약
